const { PrismaClient } = require('@prisma/client');
const EmailService = require('./emailService');

class BankService {
  constructor() {
    this.prisma = new PrismaClient();
    this.emailService = new EmailService();
    this.isMonitoring = false;
    this.monitoringStats = {
      startTime: null,
      totalEmailsProcessed: 0,
      lastEmailTime: null,
      averageProcessingTime: 0
    };
  }

  // K·∫øt n·ªëi email service
  async connect() {
    try {
      if (!process.env.EMAIL_USER || !process.env.EMAIL_PASSWORD) {
        throw new Error('Email credentials not configured');
      }

      await this.emailService.connect();
      console.log('‚úÖ Bank service connected successfully');
      return true;
    } catch (error) {
      console.error('‚ùå Failed to connect bank service:', error);
      return false;
    }
  }

  // B·∫Øt ƒë·∫ßu monitoring v·ªõi adaptive polling
  async startMonitoring() {
    try {
      if (this.isMonitoring) {
        console.log('‚ö†Ô∏è Bank monitoring already running');
        return;
      }

      const connected = await this.connect();
      if (!connected) {
        throw new Error('Failed to connect to email service');
      }

      // Kh·ªüi t·∫°o monitoring stats
      this.monitoringStats.startTime = new Date();
      this.monitoringStats.totalEmailsProcessed = 0;

      await this.emailService.startMonitoring();
      this.isMonitoring = true;
      console.log('üè¶ Bank monitoring started with adaptive polling');
      
      // B·∫Øt ƒë·∫ßu monitoring stats
      this.startMonitoringStats();
      
    } catch (error) {
      console.error('‚ùå Failed to start bank monitoring:', error);
      throw error;
    }
  }

  // D·ª´ng monitoring
  stopMonitoring() {
    this.isMonitoring = false;
    this.emailService.stopMonitoring();
    console.log('üè¶ Bank monitoring stopped');
  }

  // B·∫Øt ƒë·∫ßu monitoring stats
  startMonitoringStats() {
    setInterval(() => {
      this.logMonitoringStats();
    }, 60000); // Log stats m·ªói ph√∫t
  }

  // Log monitoring stats
  logMonitoringStats() {
    if (!this.isMonitoring) return;

    const uptime = Date.now() - this.monitoringStats.startTime.getTime();
    const uptimeMinutes = Math.floor(uptime / 60000);
    
    console.log(`üìä Monitoring Stats (${uptimeMinutes}min uptime):`);
    console.log(`   üìß Total emails processed: ${this.monitoringStats.totalEmailsProcessed}`);
    console.log(`   ‚è±Ô∏è Average processing time: ${this.monitoringStats.averageProcessingTime.toFixed(2)}ms`);
    console.log(`   üìÖ Last email time: ${this.monitoringStats.lastEmailTime || 'None'}`);
    console.log(`   üîÑ Current interval: ${this.emailService.adaptiveInterval}ms`);
  }

  // Force check email ngay l·∫≠p t·ª©c
  async forceCheckEmails() {
    try {
      console.log('üîç Force checking emails...');
      const hasNewEmails = await this.emailService.forceCheck();
      
      if (hasNewEmails) {
        this.monitoringStats.totalEmailsProcessed++;
        this.monitoringStats.lastEmailTime = new Date();
      }
      
      return hasNewEmails;
    } catch (error) {
      console.error('‚ùå Error in force check:', error);
      return false;
    }
  }

  // C·∫≠p nh·∫≠t polling interval
  updatePollingInterval(newInterval) {
    this.emailService.updateInterval(newInterval);
  }

  // L·∫•y th·ªëng k√™ giao d·ªãch ng√¢n h√†ng
  async getBankStats(userId = null) {
    try {
      const whereClause = userId ? { userId } : {};
      
      const stats = await this.prisma.bankTransaction.groupBy({
        by: ['bankName', 'type'],
        where: whereClause,
        _count: {
          id: true
        },
        _sum: {
          amount: true
        }
      });

      const totalStats = await this.prisma.bankTransaction.aggregate({
        where: whereClause,
        _count: {
          id: true
        },
        _sum: {
          amount: true
        }
      });

      const emailStats = await this.emailService.getEmailStats();

      return {
        totalTransactions: totalStats._count.id,
        totalAmount: totalStats._sum.amount || 0,
        byBank: stats.reduce((acc, stat) => {
          const key = `${stat.bankName}_${stat.type}`;
          acc[key] = {
            bank: stat.bankName,
            type: stat.type,
            count: stat._count.id,
            amount: stat._sum.amount || 0
          };
          return acc;
        }, {}),
        emailStats: emailStats,
        monitoringStats: this.monitoringStats
      };
    } catch (error) {
      console.error('‚ùå Error getting bank stats:', error);
      return null;
    }
  }

  // L·∫•y l·ªãch s·ª≠ giao d·ªãch ng√¢n h√†ng
  async getBankTransactions(userId = null, limit = 10) {
    try {
      const whereClause = userId ? { userId } : {};
      
      const transactions = await this.prisma.bankTransaction.findMany({
        where: whereClause,
        orderBy: { date: 'desc' },
        take: limit,
        include: {
          expense: true,
          incomes: true
        }
      });

      return transactions.map(tx => ({
        id: tx.id,
        bankName: tx.bankName,
        amount: tx.amount,
        type: tx.type,
        description: tx.description,
        date: tx.date,
        processed: tx.processed,
        aiProcessed: tx.aiProcessed,
        aiCategory: tx.aiCategory,
        aiConfidence: tx.aiConfidence,
        relatedExpense: tx.expense,
        relatedIncome: tx.incomes[0] || null
      }));
    } catch (error) {
      console.error('‚ùå Error getting bank transactions:', error);
      return [];
    }
  }

  // L·∫•y giao d·ªãch theo ng√¢n h√†ng
  async getTransactionsByBank(bankName, userId = null) {
    try {
      const whereClause = {
        bankName: bankName,
        ...(userId && { userId })
      };

      const transactions = await this.prisma.bankTransaction.findMany({
        where: whereClause,
        orderBy: { date: 'desc' },
        include: {
          expense: true,
          incomes: true
        }
      });

      return transactions;
    } catch (error) {
      console.error(`‚ùå Error getting transactions for ${bankName}:`, error);
      return [];
    }
  }

  // X·ª≠ l√Ω giao d·ªãch th·ªß c√¥ng
  async processTransactionManually(transactionId, userId, category, type) {
    try {
      const transaction = await this.prisma.bankTransaction.findUnique({
        where: { id: transactionId }
      });

      if (!transaction) {
        throw new Error('Transaction not found');
      }

      // C·∫≠p nh·∫≠t th√¥ng tin AI
      await this.prisma.bankTransaction.update({
        where: { id: transactionId },
        data: {
          aiCategory: category,
          aiConfidence: 1.0,
          aiProcessed: true
        }
      });

      // T·∫°o giao d·ªãch t∆∞∆°ng ·ª©ng
      if (type === 'income') {
        await this.prisma.income.create({
          data: {
            userId,
            source: category.toLowerCase(),
            amount: transaction.amount,
            description: transaction.description,
            aiCategory: category,
            aiConfidence: 1.0,
            bankTransactionId: transaction.id
          }
        });
      } else {
        await this.prisma.expense.create({
          data: {
            userId,
            category,
            amount: transaction.amount,
            note: transaction.description,
            source: 'bank',
            bankRef: transaction.reference
          }
        });
      }

      // ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω
      await this.prisma.bankTransaction.update({
        where: { id: transactionId },
        data: { processed: true }
      });

      console.log(`‚úÖ Manually processed transaction ${transactionId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Error processing transaction manually:', error);
      return false;
    }
  }

  // L·∫•y giao d·ªãch ch∆∞a x·ª≠ l√Ω
  async getPendingTransactions(userId = null) {
    try {
      const whereClause = {
        processed: false,
        ...(userId && { userId })
      };

      const transactions = await this.prisma.bankTransaction.findMany({
        where: whereClause,
        orderBy: { date: 'desc' }
      });

      return transactions;
    } catch (error) {
      console.error('‚ùå Error getting pending transactions:', error);
      return [];
    }
  }

  // X√≥a giao d·ªãch
  async deleteTransaction(transactionId) {
    try {
      await this.prisma.bankTransaction.delete({
        where: { id: transactionId }
      });
      console.log(`‚úÖ Deleted transaction ${transactionId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Error deleting transaction:', error);
      return false;
    }
  }

  // C·∫≠p nh·∫≠t c·∫•u h√¨nh email
  async updateEmailConfig(userId, email, bankName) {
    try {
      await this.prisma.userBankConfig.upsert({
        where: { userId },
        update: {
          email,
          bankName,
          active: true
        },
        create: {
          userId,
          email,
          bankName,
          active: true
        }
      });

      console.log(`‚úÖ Updated email config for user ${userId}`);
      return true;
    } catch (error) {
      console.error('‚ùå Error updating email config:', error);
      return false;
    }
  }

  // L·∫•y c·∫•u h√¨nh email c·ªßa user
  async getUserEmailConfig(userId) {
    try {
      const config = await this.prisma.userBankConfig.findUnique({
        where: { userId }
      });
      return config;
    } catch (error) {
      console.error('‚ùå Error getting user email config:', error);
      return null;
    }
  }

  // Test k·∫øt n·ªëi email
  async testEmailConnection() {
    try {
      const connected = await this.connect();
      if (connected) {
        this.emailService.stopMonitoring();
        return {
          success: true,
          message: 'Email connection test successful'
        };
      } else {
        return {
          success: false,
          message: 'Email connection test failed'
        };
      }
    } catch (error) {
      return {
        success: false,
        message: `Email connection test failed: ${error.message}`
      };
    }
  }

  // L·∫•y th·ªëng k√™ AI
  async getAIStats() {
    try {
      const aiStats = await this.prisma.bankTransaction.groupBy({
        by: ['aiCategory'],
        where: { aiProcessed: true },
        _count: {
          id: true
        },
        _avg: {
          aiConfidence: true
        }
      });

      return aiStats.map(stat => ({
        category: stat.aiCategory,
        count: stat._count.id,
        avgConfidence: stat._avg.aiConfidence
      }));
    } catch (error) {
      console.error('‚ùå Error getting AI stats:', error);
      return [];
    }
  }

  // Retrain AI v·ªõi d·ªØ li·ªáu m·ªõi
  async retrainAI() {
    try {
      // L·∫•y t·∫•t c·∫£ giao d·ªãch ƒë√£ x·ª≠ l√Ω
      const processedTransactions = await this.prisma.bankTransaction.findMany({
        where: { aiProcessed: true },
        select: {
          description: true,
          aiCategory: true,
          aiConfidence: true
        }
      });

      // C·∫≠p nh·∫≠t AI mapping
      const categoryMapping = {};
      processedTransactions.forEach(tx => {
        if (!categoryMapping[tx.aiCategory]) {
          categoryMapping[tx.aiCategory] = [];
        }
        categoryMapping[tx.aiCategory].push(tx.description);
      });

      console.log('ü§ñ AI retraining completed');
      return {
        success: true,
        categories: Object.keys(categoryMapping),
        totalTransactions: processedTransactions.length
      };
    } catch (error) {
      console.error('‚ùå Error retraining AI:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // L·∫•y monitoring status
  getMonitoringStatus() {
    return {
      isMonitoring: this.isMonitoring,
      startTime: this.monitoringStats.startTime,
      uptime: this.isMonitoring ? Date.now() - this.monitoringStats.startTime.getTime() : 0,
      totalEmailsProcessed: this.monitoringStats.totalEmailsProcessed,
      lastEmailTime: this.monitoringStats.lastEmailTime,
      currentInterval: this.emailService.adaptiveInterval
    };
  }

  // Restart monitoring
  async restartMonitoring() {
    console.log('üîÑ Restarting bank monitoring...');
    this.stopMonitoring();
    await new Promise(resolve => setTimeout(resolve, 2000)); // ƒê·ª£i 2 gi√¢y
    await this.startMonitoring();
    console.log('‚úÖ Bank monitoring restarted');
  }
}

module.exports = BankService;

